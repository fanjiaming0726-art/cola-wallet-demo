# 手动实现三种设计模式指南

## 项目结构回顾

在开始之前，让我们先回顾一下当前项目的结构和主要类：

1. **WalletAppService**: 钱包应用服务，负责流程编排和事务控制
2. **Wallet**: 钱包聚合根，包含核心业务逻辑
3. **WalletChargeCmd**: 钱包充值命令对象，包含充值参数
4. **WalletDubboServiceImpl**: Dubbo服务实现，调用应用服务
5. **WalletService**: Dubbo服务接口

## 一、实现责任链模式

责任链模式适合用于参数校验、业务规则检查等场景。我们将使用责任链模式来处理钱包充值的各种验证逻辑。

### 步骤1：创建责任链接口和抽象处理者

首先，我们需要创建责任链的核心接口和抽象处理类。

1. 在 `wallet-domain/src/main/java/com/example/wallet/domain/validation/` 目录下创建 `ValidationHandler.java` 接口：

```java
package com.example.wallet.domain.validation;

import com.example.wallet.client.dto.WalletChargeCmd;

/**
 * 验证处理器接口 - 责任链模式的Handler
 */
public interface ValidationHandler {
    /**
     * 设置下一个处理器
     */
    void setNext(ValidationHandler nextHandler);
    
    /**
     * 处理验证
     */
    void handle(WalletChargeCmd cmd);
}
```

2. 创建抽象处理者类 `AbstractValidationHandler.java`：

```java
package com.example.wallet.domain.validation;

import com.example.wallet.client.dto.WalletChargeCmd;

/**
 * 抽象验证处理器 - 实现了责任链的基本逻辑
 */
public abstract class AbstractValidationHandler implements ValidationHandler {
    
    protected ValidationHandler nextHandler;
    
    @Override
    public void setNext(ValidationHandler nextHandler) {
        this.nextHandler = nextHandler;
    }
    
    @Override
    public void handle(WalletChargeCmd cmd) {
        // 1. 执行当前处理器的验证逻辑
        validate(cmd);
        
        // 2. 如果有下一个处理器，则传递给下一个处理器
        if (nextHandler != null) {
            nextHandler.handle(cmd);
        }
    }
    
    /**
     * 具体的验证逻辑由子类实现
     */
    protected abstract void validate(WalletChargeCmd cmd);
}
```

### 步骤2：创建具体的验证处理器

现在，我们创建具体的验证处理器，实现不同的验证逻辑。

1. **参数验证处理器**：

```java
package com.example.wallet.domain.validation.impl;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.validation.AbstractValidationHandler;

/**
 * 参数验证处理器 - 验证充值参数是否完整
 */
public class ParamValidationHandler extends AbstractValidationHandler {
    
    @Override
    protected void validate(WalletChargeCmd cmd) {
        System.out.println("[Validation] 执行参数完整性验证...");
        
        if (cmd.getWalletId() == null) {
            throw new IllegalArgumentException("钱包ID不能为空！");
        }
        
        if (cmd.getAmount() == null) {
            throw new IllegalArgumentException("充值金额不能为空！");
        }
        
        if (cmd.getCurrency() == null || cmd.getCurrency().isEmpty()) {
            throw new IllegalArgumentException("货币类型不能为空！");
        }
        
        System.out.println("[Validation] 参数完整性验证通过！");
    }
}
```

2. **金额验证处理器**：

```java
package com.example.wallet.domain.validation.impl;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.validation.AbstractValidationHandler;

/**
 * 金额验证处理器 - 验证充值金额是否合法
 */
public class AmountValidationHandler extends AbstractValidationHandler {
    
    @Override
    protected void validate(WalletChargeCmd cmd) {
        System.out.println("[Validation] 执行金额合法性验证...");
        
        if (cmd.getAmount() <= 0) {
            throw new IllegalArgumentException("充值金额必须大于0！");
        }
        
        // 可以添加更多的金额验证规则，如单日限额、单笔限额等
        if (cmd.getAmount() > 5000) {
            throw new IllegalArgumentException("单笔充值金额不能超过5000！");
        }
        
        System.out.println("[Validation] 金额合法性验证通过！");
    }
}
```

### 步骤3：创建责任链工厂

为了方便构建责任链，我们创建一个工厂类：

```java
package com.example.wallet.domain.validation;

import com.example.wallet.domain.validation.impl.AmountValidationHandler;
import com.example.wallet.domain.validation.impl.ParamValidationHandler;

/**
 * 验证责任链工厂 - 用于构建验证责任链
 */
public class ValidationChainFactory {
    
    /**
     * 创建默认的验证责任链
     */
    public static ValidationHandler createDefaultValidationChain() {
        // 创建各个验证处理器
        ValidationHandler paramHandler = new ParamValidationHandler();
        ValidationHandler amountHandler = new AmountValidationHandler();
        
        // 构建责任链：参数验证 -> 金额验证
        paramHandler.setNext(amountHandler);
        
        return paramHandler;
    }
}
```

### 步骤4：在应用服务中使用责任链

现在，我们需要修改 `WalletAppService` 类，使用责任链进行验证：

```java
package com.example.wallet.app.service;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.aggregate.Wallet;
import com.example.wallet.domain.gateway.WalletRepository;
import com.example.wallet.domain.validation.ValidationChainFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
// import org.springframework.transaction.annotation.Transactional; // 实际项目中此处应有事务管理

/**
 * 钱包应用服务 (Application Service)
 * 职责：流程编排、事务控制、权限校验。
 */
@Service
public class WalletAppService {

    @Autowired
    private WalletRepository walletRepository;

    // @Transactional
    public void charge(WalletChargeCmd cmd) {
        // 1. [应用层职责]: 使用责任链进行参数校验
        ValidationChainFactory.createDefaultValidationChain().handle(cmd);

        // 2. [流程编排]: 通过仓储加载聚合根
        Wallet wallet = walletRepository.findById(cmd.getWalletId());

        if (wallet == null) {
            // 第一次操作，创建初始钱包（聚合根）
            wallet = new Wallet(cmd.getWalletId(), 0.0);
        }

        // 3. [业务执行]: 调用聚合根的业务方法 (核心逻辑在领域层)
        wallet.charge(cmd.getAmount());

        // 4. [持久化]: 通过仓储保存聚合根
        walletRepository.save(wallet);
    }
}
```

## 二、实现模板模式

模板模式适合用于定义一个算法的骨架，而将一些步骤延迟到子类中实现。我们将使用模板模式来定义标准化的钱包充值流程。

### 步骤1：创建模板抽象类

在 `wallet-app/src/main/java/com/example/wallet/app/service/template/` 目录下创建 `AbstractWalletChargeFlow.java` 抽象类：

```java
package com.example.wallet.app.service.template;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.aggregate.Wallet;
import com.example.wallet.domain.gateway.WalletRepository;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * 钱包充值流程模板 - 模板模式的抽象类
 */
public abstract class AbstractWalletChargeFlow {
    
    @Autowired
    protected WalletRepository walletRepository;
    
    /**
     * 充值流程模板方法 - 定义了算法的骨架
     */
    public final void execute(WalletChargeCmd cmd) {
        // 1. 执行验证
        validate(cmd);
        
        // 2. 准备充值
        prepareCharge(cmd);
        
        // 3. 执行充值
        Wallet wallet = doCharge(cmd);
        
        // 4. 完成充值
        completeCharge(cmd, wallet);
    }
    
    /**
     * 验证步骤 - 由子类实现具体验证逻辑
     */
    protected abstract void validate(WalletChargeCmd cmd);
    
    /**
     * 准备充值步骤 - 可以由子类重写
     */
    protected void prepareCharge(WalletChargeCmd cmd) {
        System.out.println("[Template] 准备充值...");
        // 默认实现，可以由子类重写
    }
    
    /**
     * 执行充值步骤 - 核心充值逻辑
     */
    protected final Wallet doCharge(WalletChargeCmd cmd) {
        System.out.println("[Template] 执行充值...");
        
        // 加载或创建钱包
        Wallet wallet = walletRepository.findById(cmd.getWalletId());
        if (wallet == null) {
            wallet = new Wallet(cmd.getWalletId(), 0.0);
        }
        
        // 调用聚合根的充值方法
        wallet.charge(cmd.getAmount());
        
        // 保存钱包
        walletRepository.save(wallet);
        
        return wallet;
    }
    
    /**
     * 完成充值步骤 - 可以由子类重写
     */
    protected void completeCharge(WalletChargeCmd cmd, Wallet wallet) {
        System.out.println("[Template] 充值完成，钱包ID: " + wallet.getId() + "，新余额: " + wallet.getBalance());
        // 默认实现，可以由子类重写
    }
}
```

### 步骤2：创建具体的模板实现

```java
package com.example.wallet.app.service.template.impl;

import com.example.wallet.app.service.template.AbstractWalletChargeFlow;
import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.validation.ValidationChainFactory;
import org.springframework.stereotype.Component;

/**
 * 默认钱包充值流程 - 模板模式的具体实现
 */
@Component
public class DefaultWalletChargeFlow extends AbstractWalletChargeFlow {
    
    @Override
    protected void validate(WalletChargeCmd cmd) {
        System.out.println("[Template] 执行默认验证流程...");
        // 使用责任链进行验证
        ValidationChainFactory.createDefaultValidationChain().handle(cmd);
    }
    
    @Override
    protected void prepareCharge(WalletChargeCmd cmd) {
        super.prepareCharge(cmd);
        // 可以添加额外的准备逻辑
        System.out.println("[Template] 正在准备充值，钱包ID: " + cmd.getWalletId() + "，金额: " + cmd.getAmount());
    }
    
    @Override
    protected void completeCharge(WalletChargeCmd cmd, Wallet wallet) {
        super.completeCharge(cmd, wallet);
        // 可以添加额外的完成逻辑，如发送通知等
        System.out.println("[Template] 充值完成通知已发送！");
    }
}
```

### 步骤3：在应用服务中使用模板

现在，我们需要修改 `WalletAppService` 类，使用模板模式进行充值：

```java
package com.example.wallet.app.service;

import com.example.wallet.app.service.template.AbstractWalletChargeFlow;
import com.example.wallet.client.dto.WalletChargeCmd;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
// import org.springframework.transaction.annotation.Transactional; // 实际项目中此处应有事务管理

/**
 * 钱包应用服务 (Application Service)
 * 职责：流程编排、事务控制、权限校验。
 */
@Service
public class WalletAppService {

    @Autowired
    private AbstractWalletChargeFlow walletChargeFlow;

    // @Transactional
    public void charge(WalletChargeCmd cmd) {
        // 使用模板模式执行充值流程
        walletChargeFlow.execute(cmd);
    }
}
```

## 三、实现策略模式

策略模式适合用于处理不同的业务规则或算法，如不同的支付方式、不同的折扣策略等。我们将使用策略模式来处理不同的充值方式。

### 步骤1：创建策略接口和具体策略

1. 在 `wallet-domain/src/main/java/com/example/wallet/domain/service/strategy/` 目录下创建 `ChargeStrategy.java` 接口：

```java
package com.example.wallet.domain.service.strategy;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.aggregate.Wallet;

/**
 * 充值策略接口 - 策略模式的Strategy
 */
public interface ChargeStrategy {
    
    /**
     * 获取策略名称
     */
    String getStrategyName();
    
    /**
     * 执行充值策略
     */
    void execute(WalletChargeCmd cmd, Wallet wallet);
}
```

2. 创建具体的策略实现类：

**余额充值策略**：

```java
package com.example.wallet.domain.service.strategy.impl;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.aggregate.Wallet;
import com.example.wallet.domain.service.strategy.ChargeStrategy;

/**
 * 余额充值策略 - 直接增加余额
 */
public class BalanceChargeStrategy implements ChargeStrategy {
    
    @Override
    public String getStrategyName() {
        return "BALANCE";
    }
    
    @Override
    public void execute(WalletChargeCmd cmd, Wallet wallet) {
        System.out.println("[Strategy] 使用余额充值策略...");
        // 直接增加余额（这里复用了Wallet的charge方法）
        wallet.charge(cmd.getAmount());
    }
}
```

**银行卡充值策略**：

```java
package com.example.wallet.domain.service.strategy.impl;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.aggregate.Wallet;
import com.example.wallet.domain.service.strategy.ChargeStrategy;

/**
 * 银行卡充值策略 - 可能包含手续费、积分等逻辑
 */
public class BankCardChargeStrategy implements ChargeStrategy {
    
    private static final double FEE_RATE = 0.001; // 手续费率：0.1%
    
    @Override
    public String getStrategyName() {
        return "BANK_CARD";
    }
    
    @Override
    public void execute(WalletChargeCmd cmd, Wallet wallet) {
        System.out.println("[Strategy] 使用银行卡充值策略...");
        
        // 计算手续费
        double fee = cmd.getAmount() * FEE_RATE;
        System.out.println("[Strategy] 手续费: " + fee);
        
        // 实际到账金额 = 充值金额 - 手续费
        double actualAmount = cmd.getAmount() - fee;
        
        // 增加余额
        wallet.charge(actualAmount);
        
        // 可以添加积分奖励等额外逻辑
        System.out.println("[Strategy] 银行卡充值奖励积分: " + (int)cmd.getAmount());
    }
}
```

### 步骤2：创建策略工厂

为了方便获取和管理策略，我们创建一个策略工厂：

```java
package com.example.wallet.domain.service.factory;

import com.example.wallet.domain.service.strategy.ChargeStrategy;
import com.example.wallet.domain.service.strategy.impl.BalanceChargeStrategy;
import com.example.wallet.domain.service.strategy.impl.BankCardChargeStrategy;

import java.util.HashMap;
import java.util.Map;

/**
 * 充值策略工厂 - 用于获取不同的充值策略
 */
public class ChargeStrategyFactory {
    
    private static final Map<String, ChargeStrategy> STRATEGY_MAP = new HashMap<>();
    
    // 静态初始化策略
    static {
        STRATEGY_MAP.put("BALANCE", new BalanceChargeStrategy());
        STRATEGY_MAP.put("BANK_CARD", new BankCardChargeStrategy());
    }
    
    /**
     * 获取充值策略
     */
    public static ChargeStrategy getStrategy(String strategyName) {
        ChargeStrategy strategy = STRATEGY_MAP.get(strategyName);
        if (strategy == null) {
            // 默认使用余额充值策略
            strategy = new BalanceChargeStrategy();
        }
        return strategy;
    }
}
```

### 步骤3：修改模板模式，集成策略模式

现在，我们需要修改模板模式的实现，集成策略模式：

```java
package com.example.wallet.domain.aggregate;

import com.example.wallet.client.dto.WalletChargeCmd;
import com.example.wallet.domain.service.factory.ChargeStrategyFactory;
import com.example.wallet.domain.service.strategy.ChargeStrategy;

/**
 * 钱包聚合根
 * 包含钱包的核心状态和业务逻辑。
 */
public class Wallet {
    private Long id;
    private Double balance;

    public Wallet(Long id, Double balance) {
        this.id = id;
        this.balance = balance;
    }

    /** 核心业务方法：充值 */
    public void charge(Double amount) {
        // [DDD 核心业务逻辑]
        if (amount == null || amount <= 0) {
            throw new IllegalArgumentException("充值金额必须大于0！");
        }

        // 1. 检查业务规则 (例如，每日限额检查...)
        // if (amount > 5000) { throw new RuntimeException("单笔充值不能超过5000"); }

        // 2. 增加余额
        this.balance += amount;

        System.out.println("[Domain] 钱包 ID: " + id + " 充值 " + amount + "，新余额: " + this.balance);
    }
    
    /**
     * 使用策略模式的充值方法
     */
    public void chargeWithStrategy(WalletChargeCmd cmd) {
        // 根据命令中的货币类型或其他参数选择策略
        String strategyName = cmd.getCurrency(); // 假设currency字段存储的是充值方式
        
        // 获取策略
        ChargeStrategy strategy = ChargeStrategyFactory.getStrategy(strategyName);
        
        // 执行策略
        strategy.execute(cmd, this);
    }

    public Long getId() { return id; }
    public Double getBalance() { return balance; }
}
```

### 步骤4：修改模板模式的doCharge方法

```java
protected final Wallet doCharge(WalletChargeCmd cmd) {
    System.out.println("[Template] 执行充值...");
    
    // 加载或创建钱包
    Wallet wallet = walletRepository.findById(cmd.getWalletId());
    if (wallet == null) {
        wallet = new Wallet(cmd.getWalletId(), 0.0);
    }
    
    // 调用聚合根的策略充值方法
    wallet.chargeWithStrategy(cmd);
    
    // 保存钱包
    walletRepository.save(wallet);
    
    return wallet;
}
```

## 四、整合三种模式

现在，我们已经实现了三种设计模式，让我们将它们整合到一起：

1. **责任链模式**：用于处理各种验证逻辑
2. **模板模式**：用于定义充值流程的骨架
3. **策略模式**：用于处理不同的充值方式

### 最终的充值流程

1. Dubbo服务接收充值请求
2. 应用服务调用充值流程模板
3. 模板调用责任链进行验证
4. 模板执行充值操作，调用聚合根
5. 聚合根使用策略模式执行具体的充值逻辑
6. 模板完成充值流程

## 五、测试验证

为了验证我们的实现，我们可以创建一个简单的测试类：

```java
package com.example.wallet.app.service;

import com.example.wallet.app.service.template.AbstractWalletChargeFlow;
import com.example.wallet.client.dto.WalletChargeCmd;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class WalletAppServiceTest {
    
    @Autowired
    private WalletAppService walletAppService;
    
    @Test
    public void testCharge() {
        // 创建充值命令
        WalletChargeCmd cmd = new WalletChargeCmd(123L, 100.0, "BANK_CARD");
        
        // 执行充值
        walletAppService.charge(cmd);
        
        System.out.println("测试完成！");
    }
}
```

## 六、总结

通过手动实现这三种设计模式，我们可以看到：

1. **责任链模式**：将验证逻辑解耦，每个处理器只关注自己的验证规则，便于扩展和维护
2. **模板模式**：定义了充值流程的骨架，将不变的流程固定，将可变的部分留给子类实现
3. **策略模式**：将不同的充值方式封装成策略，便于动态切换和扩展

这三种模式的组合使用，使得我们的代码更加灵活、可扩展和可维护。

现在，您可以按照上述步骤手动实现这三种设计模式，并根据实际需求进行调整和扩展。